###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        24/Apr/2016  20:13:22
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\Gold_Razor_A\lib\common\uif.c
#    Command line =  
#        C:\Users\Administrator\Desktop\Gold_Razor_A\lib\common\uif.c -D
#        LPLD_K60 -D USE_K60DZ10 -lCN
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\FLASH\List\
#        -lB
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\FLASH\List\
#        -o
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\IAR EWARM\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\app\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\app\Source\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\CPU\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\common\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\LPLD\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\FatFs\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\USB\common\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\..\..\..\lib\USB\class\
#        -Ol -I "D:\IAR EWARM\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\FLASH\List\uif.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\Gold_Razor_A\project\Gold_Razor_A\iar\FLASH\Obj\uif.o
#
###############################################################################

C:\Users\Administrator\Desktop\Gold_Razor_A\lib\common\uif.c
      1          /**
      2           * @file uif.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief 提供简单的交互接口
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * The commands, set/show parameters, and prompt are configured 
     10           * at the project level
     11           *
     12           * 版权所有:北京拉普兰德电子技术有限公司
     13           * http://www.lpld.cn
     14           * mail:support@lpld.cn
     15           *
     16           * @par
     17           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     18           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     19           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     20           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     21           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     22           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     23           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     24           */
     25          
     26          #include "common.h"
     27          #include "uif.h"
     28          
     29          /********************************************************************/
     30          /*
     31           * Global messages -- constant strings
     32           */

   \                                 In section .rodata, align 4
     33          const int8 HELPMSG[] =
   \                     HELPMSG:
   \   00000000   0x45 0x6E          DC8 "Enter 'help' for help.\012"
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x27 0x68    
   \              0x65 0x6C    
   \              0x70 0x27    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x68    
   \              0x65 0x6C    
   \              0x70 0x2E    
   \              0x0A 0x00    
     34              "Enter 'help' for help.\n";
     35          

   \                                 In section .rodata, align 4
     36          const int8 INVARG[] =
   \                     INVARG:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     37              "Error: Invalid argument: %s\n";
     38          

   \                                 In section .rodata, align 4
     39          const int8 INVALUE[] = 
   \                     INVALUE:
   \   00000000   0x45 0x72          DC8 "Error: Invalid value: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0
     40              "Error: Invalid value: %s\n";
     41          
     42          /*
     43           * Strings used by this file only
     44           */

   \                                 In section .rodata, align 4
     45          static const int8 INVCMD[] =
   \                     INVCMD:
   \   00000000   0x45 0x72          DC8 "Error: No such command: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x73 0x75    
   \              0x63 0x68    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
     46              "Error: No such command: %s\n";
     47          

   \                                 In section .rodata, align 4
     48          static const int8 HELPFORMAT[] = 
   \                     HELPFORMAT:
   \   00000000   0x25 0x38          DC8 "%8s  %-25s %s %s\012"
   \              0x73 0x20    
   \              0x20 0x25    
   \              0x2D 0x32    
   \              0x35 0x73    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
     49              "%8s  %-25s %s %s\n";
     50          

   \                                 In section .rodata, align 4
     51          static const int8 SYNTAX[] = 
   \                     SYNTAX:
   \   00000000   0x45 0x72          DC8 "Error: Invalid syntax for: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x73    
   \              0x79 0x6E    
   \              0x74 0x61    
   \              0x78 0x20    
   \              0x66 0x6F    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0
     52              "Error: Invalid syntax for: %s\n";
     53          

   \                                 In section .rodata, align 4
     54          static const int8 INVOPT[] = 
   \                     INVOPT:
   \   00000000   0x45 0x72          DC8 "Error:  Invalid set/show option: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x20    
   \              0x49 0x6E    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x2F    
   \              0x73 0x68    
   \              0x6F 0x77    
   \              0x20 0x6F    
   \              0x70 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     55              "Error:  Invalid set/show option: %s\n";
     56          

   \                                 In section .rodata, align 4
     57          static const int8 OPTFMT[] = 
   \                     OPTFMT:
   \   00000000   0x25 0x31          DC8 "%12s: "
   \              0x32 0x73    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0
     58              "%12s: ";
     59          

   \                                 In section .bss, align 4
     60          static int8 cmdline1 [UIF_MAX_LINE];
   \                     cmdline1:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
     61          static int8 cmdline2 [UIF_MAX_LINE];
   \                     cmdline2:
   \   00000000                      DS8 80
     62          
     63          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     64          int8 *get_line (int8 *line)
     65          {
   \                     get_line: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     66              int32 pos;
     67              int32 ch;
     68          
     69              pos = 0;
   \   00000004   0x2500             MOVS     R5,#+0
     70              ch = (int32)in_char();
   \   00000006   0x.... 0x....      BL       in_char
   \   0000000A   0xE00D             B.N      ??get_line_0
     71              while ( (ch != 0x0D /* CR */) &&
     72                      (ch != 0x0A /* LF/NL */) &&
     73                      (pos < UIF_MAX_LINE))
     74              {
     75                  switch (ch)
     76                  {
     77                      case 0x08:      /* Backspace */
     78                      case 0x7F:      /* Delete */
     79                          if (pos > 0)
     80                          {
     81                              pos -= 1;
     82                              out_char(0x08);    /* backspace */
     83                              out_char(' ');
     84                              out_char(0x08);    /* backspace */
     85                          }
     86                          break;
     87                      default:
     88                          if ((pos+1) < UIF_MAX_LINE)
   \                     ??get_line_1: (+1)
   \   0000000C   0x1C69             ADDS     R1,R5,#+1
   \   0000000E   0x2950             CMP      R1,#+80
   \   00000010   0xDA08             BGE.N    ??get_line_2
     89                          {
     90                              if ((ch > 0x1f) && (ch < 0x80))
   \   00000012   0xF1B0 0x0120      SUBS     R1,R0,#+32
   \   00000016   0x2960             CMP      R1,#+96
   \   00000018   0xD204             BCS.N    ??get_line_2
     91                              {
     92                                  line[pos++] = (int8)ch;
   \   0000001A   0x5528             STRB     R0,[R5, R4]
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
     93                                  out_char((int8)ch);
   \   0000001E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       out_char
     94                              }
     95                          }
     96                          break;
     97                  }
     98                  ch = (int32)in_char();
   \                     ??get_line_2: (+1)
   \                     ??get_line_3: (+1)
   \   00000024   0x.... 0x....      BL       in_char
   \                     ??get_line_0: (+1)
   \   00000028   0x280D             CMP      R0,#+13
   \   0000002A   0xD015             BEQ.N    ??get_line_4
   \   0000002C   0x280A             CMP      R0,#+10
   \   0000002E   0xD013             BEQ.N    ??get_line_4
   \   00000030   0x2D50             CMP      R5,#+80
   \   00000032   0xDA11             BGE.N    ??get_line_4
   \   00000034   0x0001             MOVS     R1,R0
   \   00000036   0x2908             CMP      R1,#+8
   \   00000038   0xD001             BEQ.N    ??get_line_5
   \   0000003A   0x297F             CMP      R1,#+127
   \   0000003C   0xD1E6             BNE.N    ??get_line_1
   \                     ??get_line_5: (+1)
   \   0000003E   0x2D01             CMP      R5,#+1
   \   00000040   0xDB09             BLT.N    ??get_line_6
   \   00000042   0x1E6D             SUBS     R5,R5,#+1
   \   00000044   0x2008             MOVS     R0,#+8
   \   00000046   0x.... 0x....      BL       out_char
   \   0000004A   0x2020             MOVS     R0,#+32
   \   0000004C   0x.... 0x....      BL       out_char
   \   00000050   0x2008             MOVS     R0,#+8
   \   00000052   0x.... 0x....      BL       out_char
   \                     ??get_line_6: (+1)
   \   00000056   0xE7E5             B.N      ??get_line_3
     99              }
    100              line[pos] = '\0';
   \                     ??get_line_4: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x5528             STRB     R0,[R5, R4]
    101              out_char(0x0D);    /* CR */
   \   0000005C   0x200D             MOVS     R0,#+13
   \   0000005E   0x.... 0x....      BL       out_char
    102              out_char(0x0A);    /* LF */
   \   00000062   0x200A             MOVS     R0,#+10
   \   00000064   0x.... 0x....      BL       out_char
    103          
    104              return line;
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    105          }
    106          
    107          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    108          int32 make_argv (int8 *cmdline, int8 *argv[])
    109          {
   \                     make_argv: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    110              int32 argc, i, in_text;
    111          
    112              /* 
    113               * Break cmdline into strings and argv
    114               * It is permissible for argv to be NULL, in which case
    115               * the purpose of this routine becomes to count args
    116               */
    117              argc = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    118              i = 0;
   \   00000004   0x2300             MOVS     R3,#+0
    119              in_text = FALSE;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0xE005             B.N      ??make_argv_0
    120              while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
    121              {
    122                  if (((cmdline[i] == ' ')   ||
    123                       (cmdline[i] == '\t')) )
    124                  {
    125                      if (in_text)
   \                     ??make_argv_1: (+1)
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD002             BEQ.N    ??make_argv_2
    126                      {
    127                          /* end of command line argument */
    128                          cmdline[i] = '\0';
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0x541C             STRB     R4,[R3, R0]
    129                          in_text = FALSE;
   \   00000012   0x2400             MOVS     R4,#+0
    130                      }
    131                      else
    132                      {
    133                          /* still looking for next argument */
    134                          
    135                      }
    136                  }
    137                  else
    138                  {
    139                      /* got non-whitespace character */
    140                      if (in_text)
    141                      {
    142                      }
    143                      else
    144                      {
    145                          /* start of an argument */
    146                          in_text = TRUE;
    147                          if (argc < UIF_MAX_ARGS)
    148                          {
    149                              if (argv != NULL)
    150                                  argv[argc] = &cmdline[i];
    151                              argc++;
    152                          }
    153                          else
    154                              /*return argc;*/
    155                              break;
    156                      }
    157          
    158                  }
    159                  i++;    /* proceed to next character */
   \                     ??make_argv_2: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \                     ??make_argv_0: (+1)
   \   00000016   0x561D             LDRSB    R5,[R3, R0]
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD011             BEQ.N    ??make_argv_3
   \   0000001C   0x561D             LDRSB    R5,[R3, R0]
   \   0000001E   0x2D20             CMP      R5,#+32
   \   00000020   0xD0F3             BEQ.N    ??make_argv_1
   \   00000022   0x561D             LDRSB    R5,[R3, R0]
   \   00000024   0x2D09             CMP      R5,#+9
   \   00000026   0xD0F0             BEQ.N    ??make_argv_1
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD1F3             BNE.N    ??make_argv_2
   \   0000002C   0x2401             MOVS     R4,#+1
   \   0000002E   0x2A0A             CMP      R2,#+10
   \   00000030   0xDA06             BGE.N    ??make_argv_4
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD002             BEQ.N    ??make_argv_5
   \   00000036   0x181D             ADDS     R5,R3,R0
   \   00000038   0xF841 0x5022      STR      R5,[R1, R2, LSL #+2]
   \                     ??make_argv_5: (+1)
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
   \   0000003E   0xE7E9             B.N      ??make_argv_2
    160              }
    161              if (argv != NULL)
   \                     ??make_argv_4: (+1)
   \                     ??make_argv_3: (+1)
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD002             BEQ.N    ??make_argv_6
    162                  argv[argc] = NULL;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    163              return argc;
   \                     ??make_argv_6: (+1)
   \   0000004A   0x0010             MOVS     R0,R2
   \   0000004C   0xBC30             POP      {R4,R5}
   \   0000004E   0x4770             BX       LR               ;; return
    164          }
    165          
    166          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    167          void run_cmd (void)
    168          {
   \                     run_cmd: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    169              /*
    170               * Global array of pointers to emulate C argc,argv interface
    171               */
    172              int32 argc;
    173              int8 *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
    174          
    175              get_line(cmdline1);
   \   00000004   0x....             LDR.N    R0,??DataTable3_3
   \   00000006   0x.... 0x....      BL       get_line
    176          
    177              if (!(argc = make_argv(cmdline1,argv)))
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x....             LDR.N    R0,??DataTable3_3
   \   0000000E   0x.... 0x....      BL       make_argv
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD108             BNE.N    ??run_cmd_0
    178              {
    179                  /* no command entered, just a blank line */
    180                  strcpy(cmdline1,cmdline2);
   \   00000018   0x....             LDR.N    R1,??DataTable3_4
   \   0000001A   0x....             LDR.N    R0,??DataTable3_3
   \   0000001C   0x.... 0x....      BL       strcpy
    181                  argc = make_argv(cmdline1,argv);
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0x....             LDR.N    R0,??DataTable3_3
   \   00000024   0x.... 0x....      BL       make_argv
   \   00000028   0x0004             MOVS     R4,R0
    182              }
    183              cmdline2[0] = '\0';
   \                     ??run_cmd_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable3_4
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    184          
    185              if (argc)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD040             BEQ.N    ??run_cmd_1
    186              {
    187                  int32 i;
    188                  for (i = 0; i < UIF_NUM_CMD; i++)
   \   00000034   0x2500             MOVS     R5,#+0
   \   00000036   0xE000             B.N      ??run_cmd_2
   \                     ??run_cmd_3: (+1)
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \                     ??run_cmd_2: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable3_5
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xDA32             BGE.N    ??run_cmd_4
    189                  {
    190                      if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
   \   00000042   0x9900             LDR      R1,[SP, #+0]
   \   00000044   0x....             LDR.N    R0,??DataTable3_6
   \   00000046   0x221C             MOVS     R2,#+28
   \   00000048   0xFB02 0x0005      MLA      R0,R2,R5,R0
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x.... 0x....      BL       strcasecmp
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD1F0             BNE.N    ??run_cmd_3
    191                      {
    192                          if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
    193                              ((argc-1) <= UIF_CMDTAB[i].max_args))
   \   00000056   0x1E60             SUBS     R0,R4,#+1
   \   00000058   0x....             LDR.N    R1,??DataTable3_6
   \   0000005A   0x221C             MOVS     R2,#+28
   \   0000005C   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000060   0x6849             LDR      R1,[R1, #+4]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xDB1B             BLT.N    ??run_cmd_5
   \   00000066   0x....             LDR.N    R0,??DataTable3_6
   \   00000068   0x211C             MOVS     R1,#+28
   \   0000006A   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000006E   0x6880             LDR      R0,[R0, #+8]
   \   00000070   0x1E61             SUBS     R1,R4,#+1
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xDB13             BLT.N    ??run_cmd_5
    194                          {
    195                              if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
   \   00000076   0x....             LDR.N    R0,??DataTable3_6
   \   00000078   0x211C             MOVS     R1,#+28
   \   0000007A   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000007E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000080   0x07C0             LSLS     R0,R0,#+31
   \   00000082   0xD503             BPL.N    ??run_cmd_6
    196                              {
    197                                  strcpy(cmdline2,argv[0]);
   \   00000084   0x9900             LDR      R1,[SP, #+0]
   \   00000086   0x....             LDR.N    R0,??DataTable3_4
   \   00000088   0x.... 0x....      BL       strcpy
    198                              }
    199                              UIF_CMDTAB[i].func(argc,argv);
   \                     ??run_cmd_6: (+1)
   \   0000008C   0xA900             ADD      R1,SP,#+0
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x....             LDR.N    R2,??DataTable3_6
   \   00000092   0x231C             MOVS     R3,#+28
   \   00000094   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   00000098   0x6912             LDR      R2,[R2, #+16]
   \   0000009A   0x4790             BLX      R2
    200                              return;
   \   0000009C   0xE00B             B.N      ??run_cmd_7
    201                          }
    202                          else
    203                          {
    204                              printf(SYNTAX,argv[0]);
   \                     ??run_cmd_5: (+1)
   \   0000009E   0x9900             LDR      R1,[SP, #+0]
   \   000000A0   0x....             LDR.N    R0,??DataTable3_7
   \   000000A2   0x.... 0x....      BL       printf
    205                              return;
   \   000000A6   0xE006             B.N      ??run_cmd_7
    206                          }
    207                      }
    208                  }
    209                  printf(INVCMD,argv[0]);
   \                     ??run_cmd_4: (+1)
   \   000000A8   0x9900             LDR      R1,[SP, #+0]
   \   000000AA   0x....             LDR.N    R0,??DataTable3_8
   \   000000AC   0x.... 0x....      BL       printf
    210                  printf(HELPMSG);
   \   000000B0   0x....             LDR.N    R0,??DataTable3_9
   \   000000B2   0x.... 0x....      BL       printf
    211              }
    212          }
   \                     ??run_cmd_1: (+1)
   \                     ??run_cmd_7: (+1)
   \   000000B6   0xB00B             ADD      SP,SP,#+44
   \   000000B8   0xBD30             POP      {R4,R5,PC}       ;; return
    213          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    214          uint32 get_value (int8 *s, int32 *success, int32 base)
    215          {
   \                     get_value: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    216              uint32 value;
    217              int8 *p;
    218          
    219              value = strtoul(s,&p,base);
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       strtoul
    220              if ((value == 0) && (p == s))
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD106             BNE.N    ??get_value_0
   \   00000012   0x9900             LDR      R1,[SP, #+0]
   \   00000014   0x42A1             CMP      R1,R4
   \   00000016   0xD103             BNE.N    ??get_value_0
    221              {
    222                  *success = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6028             STR      R0,[R5, #+0]
    223                  return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE001             B.N      ??get_value_1
    224              }
    225              else
    226              {
    227                  *success = TRUE;
   \                     ??get_value_0: (+1)
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x6029             STR      R1,[R5, #+0]
    228                  return value;
   \                     ??get_value_1: (+1)
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    229              }
    230          }
    231          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    232          void uif_cmd_help (int32 argc, int8 **argv)
    233          {
   \                     uif_cmd_help: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    234              int32 index;
    235              
    236              (void)argc;
    237              (void)argv;
    238              
    239              printf("\n");
   \   00000004   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000006   0x.... 0x....      BL       printf
    240              for (index = 0; index < UIF_NUM_CMD; index++)
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0xE018             B.N      ??uif_cmd_help_0
    241              {
    242                  printf(HELPFORMAT,
    243                      UIF_CMDTAB[index].cmd,
    244                      UIF_CMDTAB[index].description,
    245                      UIF_CMDTAB[index].cmd,
    246                      UIF_CMDTAB[index].syntax);
   \                     ??uif_cmd_help_1: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable3_6
   \   00000010   0x211C             MOVS     R1,#+28
   \   00000012   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000016   0x6980             LDR      R0,[R0, #+24]
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x....             LDR.N    R0,??DataTable3_6
   \   0000001C   0x211C             MOVS     R1,#+28
   \   0000001E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000022   0x6803             LDR      R3,[R0, #+0]
   \   00000024   0x....             LDR.N    R0,??DataTable3_6
   \   00000026   0x211C             MOVS     R1,#+28
   \   00000028   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000002C   0x6942             LDR      R2,[R0, #+20]
   \   0000002E   0x....             LDR.N    R0,??DataTable3_6
   \   00000030   0x211C             MOVS     R1,#+28
   \   00000032   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x....             LDR.N    R0,??DataTable3_10
   \   0000003A   0x.... 0x....      BL       printf
    247              }
   \   0000003E   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_help_0: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable3_5
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xDBE2             BLT.N    ??uif_cmd_help_1
    248              printf("\n");
   \   00000048   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   0000004A   0x.... 0x....      BL       printf
    249          }
   \   0000004E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    250          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    251          void uif_cmd_set (int32 argc, int8 **argv)
    252          {
   \                     uif_cmd_set: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
    253              int32 index;
    254          
    255              printf("\n");
   \   00000006   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000008   0x.... 0x....      BL       printf
    256              if (argc == 1)
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0xD11D             BNE.N    ??uif_cmd_set_0
    257              {
    258                  printf("Valid 'set' options:\n");
   \   00000010   0x....             LDR.N    R0,??DataTable3_11
   \   00000012   0x.... 0x....      BL       printf
    259                  for (index = 0; index < UIF_NUM_SETCMD; ++index)
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0xE010             B.N      ??uif_cmd_set_1
    260                  {
    261                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_set_2: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable3_12
   \   0000001C   0x2114             MOVS     R1,#+20
   \   0000001E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x....             LDR.N    R0,??DataTable3_13
   \   00000026   0x.... 0x....      BL       printf
    262                      printf("%s\n",UIF_SETCMDTAB[index].syntax);
   \   0000002A   0x....             LDR.N    R0,??DataTable3_12
   \   0000002C   0x2114             MOVS     R1,#+20
   \   0000002E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000032   0x6901             LDR      R1,[R0, #+16]
   \   00000034   0x....             ADR.N    R0,??DataTable3_1  ;; "%s\n"
   \   00000036   0x.... 0x....      BL       printf
    263                  }
   \   0000003A   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_set_1: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable3_14
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xDBEA             BLT.N    ??uif_cmd_set_2
    264                  printf("\n");
   \   00000044   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000046   0x.... 0x....      BL       printf
    265                  return;
   \   0000004A   0xE038             B.N      ??uif_cmd_set_3
    266              }
    267          
    268              if (argc != 3)
   \                     ??uif_cmd_set_0: (+1)
   \   0000004C   0x2D03             CMP      R5,#+3
   \   0000004E   0xD003             BEQ.N    ??uif_cmd_set_4
    269              {
    270                  printf("Error: Invalid argument list\n");
   \   00000050   0x....             LDR.N    R0,??DataTable3_15
   \   00000052   0x.... 0x....      BL       printf
    271                  return;
   \   00000056   0xE032             B.N      ??uif_cmd_set_3
    272              }
    273          
    274              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_set_4: (+1)
   \   00000058   0x2400             MOVS     R4,#+0
   \   0000005A   0xE000             B.N      ??uif_cmd_set_5
   \                     ??uif_cmd_set_6: (+1)
   \   0000005C   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_set_5: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable3_14
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xDA27             BGE.N    ??uif_cmd_set_7
    275              {
    276                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000066   0x6871             LDR      R1,[R6, #+4]
   \   00000068   0x....             LDR.N    R0,??DataTable3_12
   \   0000006A   0x2214             MOVS     R2,#+20
   \   0000006C   0xFB02 0x0004      MLA      R0,R2,R4,R0
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x.... 0x....      BL       strcasecmp
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD1F0             BNE.N    ??uif_cmd_set_6
    277                  {
    278                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    279                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   0000007A   0x1EA8             SUBS     R0,R5,#+2
   \   0000007C   0x....             LDR.N    R1,??DataTable3_12
   \   0000007E   0x2214             MOVS     R2,#+20
   \   00000080   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000084   0x6849             LDR      R1,[R1, #+4]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xDB10             BLT.N    ??uif_cmd_set_8
   \   0000008A   0x....             LDR.N    R0,??DataTable3_12
   \   0000008C   0x2114             MOVS     R1,#+20
   \   0000008E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000092   0x6880             LDR      R0,[R0, #+8]
   \   00000094   0x1EA9             SUBS     R1,R5,#+2
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xDB08             BLT.N    ??uif_cmd_set_8
    280                      {
    281                          UIF_SETCMDTAB[index].func(argc,argv);
   \   0000009A   0x0031             MOVS     R1,R6
   \   0000009C   0x0028             MOVS     R0,R5
   \   0000009E   0x....             LDR.N    R2,??DataTable3_12
   \   000000A0   0x2314             MOVS     R3,#+20
   \   000000A2   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   000000A6   0x68D2             LDR      R2,[R2, #+12]
   \   000000A8   0x4790             BLX      R2
    282                          return;
   \   000000AA   0xE008             B.N      ??uif_cmd_set_3
    283                      }
    284                      else
    285                      {
    286                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_set_8: (+1)
   \   000000AC   0x6871             LDR      R1,[R6, #+4]
   \   000000AE   0x....             LDR.N    R0,??DataTable3_16
   \   000000B0   0x.... 0x....      BL       printf
    287                          return;
   \   000000B4   0xE003             B.N      ??uif_cmd_set_3
    288                      }
    289                  }
    290              }
    291              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_set_7: (+1)
   \   000000B6   0x6871             LDR      R1,[R6, #+4]
   \   000000B8   0x....             LDR.N    R0,??DataTable3_17
   \   000000BA   0x.... 0x....      BL       printf
    292          }
   \                     ??uif_cmd_set_3: (+1)
   \   000000BE   0xBD70             POP      {R4-R6,PC}       ;; return
    293          
    294          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    295          void uif_cmd_show (int32 argc, int8 **argv)
    296          {
   \                     uif_cmd_show: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    297              int32 index;
    298          
    299              printf("\n");
   \   00000006   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   00000008   0x.... 0x....      BL       printf
    300              if (argc == 1)
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0xD120             BNE.N    ??uif_cmd_show_0
    301              {
    302                  /*
    303                   * Show all Option settings
    304                   */
    305                  argc = 2;
   \   00000010   0x2502             MOVS     R5,#+2
    306                  argv[2] = NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x60A0             STR      R0,[R4, #+8]
    307                  for (index = 0; index < UIF_NUM_SETCMD; index++)
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0xE013             B.N      ??uif_cmd_show_1
    308                  {
    309                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_show_2: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable3_12
   \   0000001C   0x2114             MOVS     R1,#+20
   \   0000001E   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x....             LDR.N    R0,??DataTable3_13
   \   00000026   0x.... 0x....      BL       printf
    310                      UIF_SETCMDTAB[index].func(argc,argv);
   \   0000002A   0x0021             MOVS     R1,R4
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x....             LDR.N    R2,??DataTable3_12
   \   00000030   0x2314             MOVS     R3,#+20
   \   00000032   0xFB03 0x2206      MLA      R2,R3,R6,R2
   \   00000036   0x68D2             LDR      R2,[R2, #+12]
   \   00000038   0x4790             BLX      R2
    311                      printf("\n");
   \   0000003A   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   0000003C   0x.... 0x....      BL       printf
    312                  }
   \   00000040   0x1C76             ADDS     R6,R6,#+1
   \                     ??uif_cmd_show_1: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable3_14
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x4286             CMP      R6,R0
   \   00000048   0xDBE7             BLT.N    ??uif_cmd_show_2
    313                  printf("\n");
   \   0000004A   0x....             ADR.N    R0,??DataTable3  ;; "\n"
   \   0000004C   0x.... 0x....      BL       printf
    314                  return;
   \   00000050   0xE03D             B.N      ??uif_cmd_show_3
    315              }
    316          
    317              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_show_0: (+1)
   \   00000052   0x2600             MOVS     R6,#+0
   \   00000054   0xE000             B.N      ??uif_cmd_show_4
   \                     ??uif_cmd_show_5: (+1)
   \   00000056   0x1C76             ADDS     R6,R6,#+1
   \                     ??uif_cmd_show_4: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable3_14
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x4286             CMP      R6,R0
   \   0000005E   0xDA32             BGE.N    ??uif_cmd_show_6
    318              {
    319                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000060   0x6861             LDR      R1,[R4, #+4]
   \   00000062   0x....             LDR.N    R0,??DataTable3_12
   \   00000064   0x2214             MOVS     R2,#+20
   \   00000066   0xFB02 0x0006      MLA      R0,R2,R6,R0
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      BL       strcasecmp
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD1F0             BNE.N    ??uif_cmd_show_5
    320                  {
    321                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    322                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   00000074   0x1EA8             SUBS     R0,R5,#+2
   \   00000076   0x....             LDR.N    R1,??DataTable3_12
   \   00000078   0x2214             MOVS     R2,#+20
   \   0000007A   0xFB02 0x1106      MLA      R1,R2,R6,R1
   \   0000007E   0x6849             LDR      R1,[R1, #+4]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xDB1B             BLT.N    ??uif_cmd_show_7
   \   00000084   0x....             LDR.N    R0,??DataTable3_12
   \   00000086   0x2114             MOVS     R1,#+20
   \   00000088   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   0000008C   0x6880             LDR      R0,[R0, #+8]
   \   0000008E   0x1EA9             SUBS     R1,R5,#+2
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xDB13             BLT.N    ??uif_cmd_show_7
    323                      {
    324                          printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \   00000094   0x....             LDR.N    R0,??DataTable3_12
   \   00000096   0x2114             MOVS     R1,#+20
   \   00000098   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   0000009C   0x6801             LDR      R1,[R0, #+0]
   \   0000009E   0x....             LDR.N    R0,??DataTable3_13
   \   000000A0   0x.... 0x....      BL       printf
    325                          UIF_SETCMDTAB[index].func(argc,argv);
   \   000000A4   0x0021             MOVS     R1,R4
   \   000000A6   0x0028             MOVS     R0,R5
   \   000000A8   0x....             LDR.N    R2,??DataTable3_12
   \   000000AA   0x2314             MOVS     R3,#+20
   \   000000AC   0xFB03 0x2206      MLA      R2,R3,R6,R2
   \   000000B0   0x68D2             LDR      R2,[R2, #+12]
   \   000000B2   0x4790             BLX      R2
    326                          printf("\n\n");
   \   000000B4   0x....             ADR.N    R0,??DataTable3_2  ;; 0x0A, 0x0A, 0x00, 0x00
   \   000000B6   0x.... 0x....      BL       printf
    327                          return;
   \   000000BA   0xE008             B.N      ??uif_cmd_show_3
    328                      }
    329                      else
    330                      {
    331                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_show_7: (+1)
   \   000000BC   0x6861             LDR      R1,[R4, #+4]
   \   000000BE   0x....             LDR.N    R0,??DataTable3_16
   \   000000C0   0x.... 0x....      BL       printf
    332                          return;
   \   000000C4   0xE003             B.N      ??uif_cmd_show_3
    333                      }
    334                  }
    335              }
    336              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_show_6: (+1)
   \   000000C6   0x6861             LDR      R1,[R4, #+4]
   \   000000C8   0x....             LDR.N    R0,??DataTable3_17
   \   000000CA   0x.... 0x....      BL       printf
    337          }
   \                     ??uif_cmd_show_3: (+1)
   \   000000CE   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     cmdline1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     cmdline2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     UIF_NUM_CMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     UIF_CMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     SYNTAX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     INVCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     HELPMSG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     HELPFORMAT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     UIF_SETCMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x........         DC32     OPTFMT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x........         DC32     UIF_NUM_SETCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_16:
   \   00000000   0x........         DC32     INVARG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_17:
   \   00000000   0x........         DC32     INVOPT

   \                                 In section .rodata, align 2
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x56 0x61          DC8 "Valid 'set' options:\012"
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x27 0x73    
   \              0x65 0x74    
   \              0x27 0x20    
   \              0x6F 0x70    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x3A    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument list\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x0A 0x0A          DC8 "\012\012"
   \              0x00         
   \   00000003   0x00               DC8 0
    338          
    339          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   get_line
        16   -> in_char
        16   -> out_char
      16   get_value
        16   -> strtoul
       8   make_argv
      56   run_cmd
        56   -- Indirect call
        56   -> get_line
        56   -> make_argv
        56   -> printf
        56   -> strcasecmp
        56   -> strcpy
      16   uif_cmd_help
        16   -> printf
      16   uif_cmd_set
        16   -- Indirect call
        16   -> printf
        16   -> strcasecmp
      16   uif_cmd_show
        16   -- Indirect call
        16   -> printf
        16   -> strcasecmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       2  ?_0
      24  ?_1
       4  ?_2
      32  ?_3
       4  ?_4
      20  HELPFORMAT
      24  HELPMSG
      28  INVALUE
      32  INVARG
      28  INVCMD
      40  INVOPT
       8  OPTFMT
      32  SYNTAX
      80  cmdline1
      80  cmdline2
     108  get_line
      38  get_value
      80  make_argv
     186  run_cmd
      80  uif_cmd_help
     192  uif_cmd_set
     208  uif_cmd_show

 
 160 bytes in section .bss
 278 bytes in section .rodata
 964 bytes in section .text
 
 964 bytes of CODE  memory
 278 bytes of CONST memory
 160 bytes of DATA  memory

Errors: none
Warnings: none
